/*!
 *  \copyright Analog Devices
 * ****************************************************************************
 *
 * License Agreement
 *
 * Copyright (c) 2019 Analog Devices Inc.
 * All rights reserved.
 *
 * This source code is intended for the recipient only under the guidelines of
 * the non-disclosure agreement with Analog Devices Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER  LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING  FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER  DEALINGS IN THE SOFTWARE.
 * ****************************************************************************
 */
#include "bsp.h"
#include "nordic_common.h"
#include "nrf.h"
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_error.h"
#include "adi_dcb_config.h"
/* Includes for the Sys Time Save */
#include "hw_if_config.h"
#include "fds_drv.h"
#include "fds.h"
#include "adi_calendar.h"
#include "dcb_interface.h"
#include "us_tick.h"

/* The record keys in the DCB File are generated by adding fixed offeset to
  M2M2_DCB_CONFIG_BLOCK_INDEX_t enum type which is used by the adi_fds_xxx()
  apis*/
#define FDS_REC_KEY_FIXED_OFFSET 0x1000

/**@brief   Function for writing to particular index of DCB file in FDS
 *
 * @param rcrd_key: Record key within file name to be updated
 * @param data: pointer to word array(uint32_t) which needs to be written
 * @param len: length in words to write(one word = 4 bytes)
 * @return return value of type ret_code_t
 */
#ifdef PROFILE_TIME_ENABLED
uint16_t update_entry;
#endif
uint8_t adi_dcb_write_to_fds(const uint16_t rcrd_key, uint32_t *wd_dcb_data, uint16_t len_DWORD)
{
    ret_code_t rRet = DEF_FAIL;

#ifdef PROFILE_TIME_ENABLED
    uint16_t update_entry_t1 = get_micro_sec();
#endif
    rRet = adi_fds_update_entry(ADI_DCB_FILE, (rcrd_key+FDS_REC_KEY_FIXED_OFFSET), wd_dcb_data, (len_DWORD*4)); //converting length in words to length in bytes

#ifdef PROFILE_TIME_ENABLED
    update_entry = get_micro_sec() - update_entry_t1;
#endif
    rRet = (rRet == FDS_SUCCESS) ? DEF_OK : DEF_FAIL;

    return (uint8_t)rRet;
}

/**@brief   Function for reading from a particular index of DCB file in FDS
 *
 * @param rcrd_key: Record key within file name to be read from.
 * @param data: pointer to word array(uint32_t) to which words are read to.
 * @param len: length in words to read from DCB(one word = 4 bytes); after this call actual size of read values are updated in len_DWORD based on FDS record content
 * @return return value of type ret_code_t
 */
#ifdef PROFILE_TIME_ENABLED
uint16_t read_entry;
#endif
uint8_t adi_dcb_read_from_fds(const uint16_t rcrd_key, uint32_t *rd_dcb_data, uint16_t *len_DWORD)
{
    ret_code_t rRet = DEF_FAIL;
    uint16_t len_bytes = *len_DWORD * 4;

#ifdef PROFILE_TIME_ENABLED
    uint16_t read_entry_t1 = get_micro_sec();
#endif
    rRet = adi_fds_read_entry(ADI_DCB_FILE, (rcrd_key+FDS_REC_KEY_FIXED_OFFSET), rd_dcb_data, &len_bytes);

#ifdef PROFILE_TIME_ENABLED
    read_entry = get_micro_sec() - read_entry_t1;
#endif
    *len_DWORD = (len_bytes / 4);//convert length in bytes read to rd_dcb_data size(length in words)
    rRet = (rRet == FDS_SUCCESS) ? DEF_OK : DEF_FAIL;

    return (uint8_t)rRet;
}

/**@brief   Function for deleting from a particular index(specific DCB setting) of DCB file in FDS
 *
 * @param rcrd_key: Record key within file name to be deleted
 * @return return value of type ret_code_t
 */
#ifdef PROFILE_TIME_ENABLED
uint16_t del_rec;
#endif
uint8_t adi_dcb_delete_fds_settings(uint16_t dcb_rec_key)
{
    ret_code_t rRet = DEF_FAIL;
#ifdef PROFILE_TIME_ENABLED
    uint16_t del_rec_t1 = get_micro_sec();
#endif
    rRet = adi_fds_delete_record(ADI_DCB_FILE, (dcb_rec_key+FDS_REC_KEY_FIXED_OFFSET));
#ifdef PROFILE_TIME_ENABLED
    del_rec = get_micro_sec() - del_rec_t1;
#endif
    rRet = (rRet == FDS_SUCCESS) ? DEF_OK : DEF_FAIL;

    return (uint8_t)rRet;
}

/**@brief   Function for checking whether a particular index(specific DCB setting) of DCB file in FDS is present or not
 *
 * @param rcrd_key: Record key within file name to be checked
 * @return return value of type ret_code_t
 */
#ifdef PROFILE_TIME_ENABLED
uint16_t check_rec;
#endif
uint8_t adi_dcb_check_fds_entry(uint16_t dcb_rec_key)
{
    ret_code_t rRet = DEF_FAIL;
#ifdef PROFILE_TIME_ENABLED
    uint16_t check_rec_t1 = get_micro_sec();
#endif
    rRet = adi_fds_check_entry(ADI_DCB_FILE, (dcb_rec_key+FDS_REC_KEY_FIXED_OFFSET));
#ifdef PROFILE_TIME_ENABLED
    check_rec = get_micro_sec() - check_rec_t1;
#endif
    rRet = (rRet == FDS_SUCCESS) ? DEF_OK : DEF_FAIL;

    return (uint8_t)rRet;
}

/**@brief  Function for clearing the entire DCB settings written in flash(at time of factory reset)
 * @return return value of type ret_code_t
 */
#ifdef PROFILE_TIME_ENABLED
uint16_t clear_entries;
#endif
uint8_t adi_dcb_clear_fds_settings()
{
    /* Set Initial Configuration for the DCB Files */
    ret_code_t rRet = DEF_FAIL;
#ifdef PROFILE_TIME_ENABLED
    uint16_t clear_entries_t1 = get_micro_sec();
#endif
    rRet = adi_fds_clear_entries(ADI_DCB_FILE);

#ifdef PROFILE_TIME_ENABLED
    clear_entries = get_micro_sec() - clear_entries_t1;
#endif
    rRet = (rRet == FDS_SUCCESS) ? DEF_OK : DEF_FAIL;
    return (uint8_t)rRet;
}

/**@brief  Function for getting status of fds records
 * @return return value of type ret_code_t
 */
#ifdef DEBUG_DCB
void get_fds_status(fds_stat_t *stat)
{
    ret_code_t rc;

    rc = fds_stat(stat);
    APP_ERROR_CHECK(rc);

    NRF_LOG_INFO("Found %d dirty records (ready to be garbage collected).", stat->dirty_records);
    NRF_LOG_INFO("Found %d valid records.", stat->valid_records);
}
#endif